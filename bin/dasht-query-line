#!/bin/sh -e
#
# Usage: dasht-query-line [PATTERN] [DOCSET...]
#
# Searches for the given PATTERN in Dash docsets whose names loosely match the
# given DOCSETs (or in all installed Dash docsets if no DOCSETs are specified)
# and then prints the results in groups of four lines, in the following order:
#
#     name = VALUE    # value of the token that matched the PATTERN
#     type = VALUE    # type of the token, as defined in the docset
#     from = VALUE    # name of the docset this result was found in
#     url = VALUE     # URL of the API documentation for this result
#
# Whitespace characters in the PATTERN are treated as wildcards, whereas the
# SQL LIKE wildcard characters "%" and "_" are not: they are taken literally.
#
# The given PATTERN is surrounded by whitespace wildcards before searching so
# that it can match anywhere: beginning, middle, or end.  If unspecified, its
# value is assumed to be a whitespace wildcard so that it matches everything.
#
# Setup: $DASHT_DOCSETS_DIR
#
# This environment variable specifies where your Dash docsets are installed.
# If unspecified, its value is assumed to be $XDG_DATA_HOME/dasht/docsets/, or
# $HOME/.local/share/dasht/docsets/ if $XDG_DATA_HOME is also unspecified.
#
# Written in 2016 by Suraj N. Kurapati <https://github.com/sunaku/dasht>
# Distributed under the terms of the ISC license (see the LICENSE file).

: ${DASHT_DOCSETS_DIR:=${XDG_DATA_HOME:-$HOME/.local/share}/dasht/docsets}

pattern=$(echo " $1 " | sed '
  s/[%_]/\\&/g # do not treat "%" and "_" as wildcards
  s/\s\+/%/g   # treat whitespace as wildcards instead
')
test $# -gt 0 && shift      # done with the PATTERN argument; move it away
test $# -gt 0 || set -- .   # no DOCSETs were specified; match all of them

dasht-docsets "$@" | while read docset; do
  database="$DASHT_DOCSETS_DIR/$docset".docset/Contents/Resources/docSet.dsidx
  file_url="file://$(dirname "$database")/Documents/"

  dasht-query-exec "$pattern" "$database" -line | awk '
    { $1 = $1 } # strip whitespace from key

    $1 == "url" {
      # indicate the source of this result
      print "from = '"$docset"'"

      '"$(
        # unescape URI fragment intelligently
        # according to quirks of each docset:
        # blind unescape isn't always correct
        case "$docset" in
          (Erlang) echo 'gsub("%2F", "-", $3)'
                   echo 'gsub("%5F", "_", $3)' ;;
          (Elixir) echo 'gsub("%2F", "/", $3)' ;;
          (CSS)    echo 'if ($3 !~ "#.+") $3 = $3 "#wiki-content"' ;;
        esac
      )"'

      # resolve URL to filesystem location
      $3 = "'"$file_url"'" $3
    }

    /./ # reject any empty lines from input
  '
done
